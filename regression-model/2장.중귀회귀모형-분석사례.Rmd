---
---
---

# 추가변수그림

```{r echo=TRUE}
library(car)
health = read.table("./data/health.txt", header=T)
head(health,3)
h4.lm=lm(Y~X1+X2+X3+X4, data=health)
avPlots(h4.lm)
```

```{r echo=TRUE}

# 실습코드 : 잔차 e(X1|X2,X3,X4)와 잔차 e(Y|X2,X3,X4)의 산점도
h4.lm = lm(Y ~ X1+X2+X3+X4, data=health)
h4.lm.y1 = lm(Y ~ X2+X3+X4, data=health)
h4.lm.x1 = lm(X1 ~ X2+X3+X4, data=health)
h4.lm11=lm(resid(h4.lm.y1)~resid(h4.lm.x1))
plot(resid(h4.lm.x1),resid(h4.lm.y1), xlab="X1 | others", ylab = "Y | others")
abline(h4.lm11, col="blue", lwd=2)

```

# 제2장 분석사례(5강)

회귀분석 절차 소개 회귀분석 절차는 크게 4가지로 아래와 같습니다.

+-------------------------------+-----------------------------------------------------------------------------------+
| 절차                          | 내용                                                                              |
+:==============================+:==================================================================================+
| ① 데이터 경향성 확인          | 1.  목표변수와 설명변수 간 산점도 분석 및 상관관계 분석을 통해 데이터 경향성 확인 |
+-------------------------------+-----------------------------------------------------------------------------------+
| ② 모델 적합성 확인            | 1.  분산분석을 통해 모델 적합성 확인                                              |
|                               | 2.  결정계수 확인을 통해 모델 설명력 확인                                         |
|                               | 3.  잔차의 기본 가정 확인(잔차의 정규성, 등분산성, 독립성 등)                     |
+-------------------------------+-----------------------------------------------------------------------------------+
| ③ 회귀계수계산 및 유의성 확인 | 1.  설명변수 간 다중공선성 확인                                                   |
|                               | 2.  t-검정을 통해 회귀계수의 유의성 확인                                          |
|                               | 3.  목표변수에 영향을 주는 설명변수(i.e.., 영향인자) 선택 및 해석                 |
+-------------------------------+-----------------------------------------------------------------------------------+
| ④ 모델 선정                   | 1.  모델 적합성, 오차의 기본 가정 확인을 통해 최종 모델 선정                      |
+-------------------------------+-----------------------------------------------------------------------------------+

<https://heytech.tistory.com/115>

분석사례는 어떤 화학 공장에서 $NH_3$ 를 $NHO_3$ 로 산화 시키는 공정에서 중요한 두 변수 `공정의 작업 속도(SPEED)`와 `냉각수의 온도(TEMP)`가 $NH_3$ 를 $NHO_3$ 로 바꿀때 $NH_3$ 의 `손실되는 함량 %(LOSS)`에 얼마만큼의 영향을 미치는지 분석하는 사례입니다.

1.  chemical.xlsx 파일의 데이터는 일종의 표본으로 생각됩니다.
2.  설명변수는 SPEED와 TEMP 두개이고, 두개의 설명변수에 의하여 영향을 받은 반응변수는 LOSS 입니다.
3.  `회귀모형`을 선택하는 방법은 데이터의 반응변수와 설명변수의 산점도를 확인하고 많은 모형중에 어떤 모형(`회귀모형`)이 데이터에 잘 설명해줄 수 있는 모형인지 선택하는 작업입니다.\
    이 사례에서 선택한 `회귀모형`은 $LOSS = \beta _0 + \beta _1 * SPEED + \beta _2 * TEMP + \varepsilon$ 입니다.\
    $Y = \beta _0 + \beta \_1 * X_1 + \beta _2 * X_2 + \varepsilon$ 에서 변수 이름만 다르게 표현했습니다.\
    공정에서 다른 변수들도 있지만 그 변수들은 취급하지 않았거나 모든 회귀식이 100% 일치하지 않기 때문에 오차항 $\varepsilon$ 로 표시한거라 생각하고 있습니다.
4.  결과적으로 회귀분석에서 회귀식을 찾는 것은 영향력이 있는 설명변수를 찾아서 반응변수를 조절할 수 있게 회귀식을 찾는 것이라고 생각합니다.\
    회귀식은 표본데이터로부터 `회귀모형`을 선택한 후 만들어낸 식이기 때문에 모집단을 완벽히 설명하기 위한 회귀식은 아니고 어떤 설명변수가 반응변수에 영향을 많이 주는지 찾기위한 식이라고 생각합니다.\
    따라서 찾은 회귀식은 모형에 의해 추정을 해서 만들어졌기 때문에 검증도 해야하고 해석도 해서 잘 설명됐는지 보고 잘 설명하지 못했다면 더 모집단을 잘 설명할 수 있는 변수나, 모형을 찾는 과정이 필요한 것이라고 생각합니다.

## 1) 자료읽기 - ①

```{r}
library(xlsx) 
chemical=read.xlsx("./data/chemical.xlsx", 1)
head(chemical)
```

## 2) 기술통계량 및 상관계수 보기 - ①

```{r}
# 자료 요약
summary(chemical[,-1]) 
# 상관계수
cor(chemical[,-1])
```

## 3) 산점도 그리기 - ①

```{r}
par(mfrow=c(1,2), pty="s") 
plot(chemical$speed, chemical$loss, pch=19)
plot(chemical$temp, chemical$loss, pch=19)
```

## 4) 회귀모형 적합하기

```{r}
chemical.lm = lm(loss ~ speed+temp, data=chemical) 
summary(chemical.lm)
```

변수 순서에 따라 영향력이 다른가? (차이는 없다)

```{r}
chemical.lm = lm(loss ~ temp+speed, data=chemical) 
summary(chemical.lm)
```

추가변수 그림

```{r}
library(car)
avPlots(chemical.lm)
```

### 추정된 회귀방정식 1)

```{r}
# 추정된 회귀방정식 1) (chemical.lm$model과 coef(chemical.lm) 함수를 이용)
str_l = paste0("hat_", names(chemical.lm$model)[1])
str_r = paste0( round(coef(chemical.lm)["(Intercept)"], 3))
for(i in 2:length(coef(chemical.lm))) 
{
  str_r = paste0( str_r, " + ", round(coef(chemical.lm)[names(chemical.lm$model)[i]], 3),
                  "*", names(chemical.lm$model)[i])
}
paste0("추정된 회귀방정식: ", str_l, " = ", str_r)
```

### 추정된 회귀방정식 2)

```{r}
# 추정된 회귀방정식 2) 최소제곱법으로 β를 행렬방정식으로 계산
mX=as.matrix(cbind(1, chemical$speed, chemical$temp))
mY=as.matrix(chemical$loss)
mβ=solve(t(mX)%*%mX)%*%t(mX)%*%mY
paste0(" 최소제곱법 이용 : hat_loss = ", round(mβ, 3)[1], " + ",
       round(mβ, 3)[2], "*speed + ",
       round(mβ, 3)[3], "*temp")
```

### 결정계수

```{r}
# 결정계수
paste0("결정계수 R.squared = ", round(summary(chemical.lm)$r.squared, 3), "으로 ",
       round(summary(chemical.lm)$r.squared*100,1), "% 설명력이 있다.")

```

### p-value

```{r}
# p-value
α = 0.05
for(i in 2:length(coef(chemical.lm))) 
{
  p.value = round(summary(chemical.lm)$coefficients[names(chemical.lm$model)[i], "Pr(>|t|)"], 5)
  if (p.value < α )
  {
    print(paste0( names(chemical.lm$model)[i], "의 p-value 가 ", p.value, "으로서 ", 
                  names(chemical.lm$model)[1], "를(을) 설명하는데 유의하다"))
  }
  else
  {
    print(paste0( names(chemical.lm$model)[i], "의 p-value 가 ", p.value, "으로서 ", 
                  names(chemical.lm$model)[1], "를(을) 설명하는데 그리 큰 영향을 준다고 할 수 없다."))
  }
}
```

## 5) 분산분석표 구하기

```{r}
# 4) 분산분석표 구하기 ( p83 분산분석표 만들기 )
AVT = matrix(c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), nrow=3)
colnames(AVT)=colnames(anova(chemical.lm))
rownames(AVT)=c("Regression", "Residuals", "Total")

for(i in 1:(length(rownames(AVT))-1))
{
  AVT["Regression", "Df"]=AVT["Regression", "Df"]+as.double(anova(chemical.lm)[i,"Df"])
  AVT["Regression", "Sum Sq"]=AVT["Regression", "Sum Sq"]+as.double(anova(chemical.lm)[i,"Sum Sq"])
}
AVT["Residuals", "Df"]=as.double(anova(chemical.lm)["Residuals","Df"])
AVT["Residuals", "Sum Sq"]=as.double(anova(chemical.lm)["Residuals","Sum Sq"])
AVT["Total", "Df"]=AVT["Regression", "Df"]+AVT["Residuals", "Df"]
AVT["Total", "Sum Sq"]=AVT["Regression", "Sum Sq"]+AVT["Residuals", "Sum Sq"]
AVT["Regression", "Mean Sq"] = AVT["Regression", "Sum Sq"] / AVT["Regression", "Df"]
AVT["Residuals", "Mean Sq"] = AVT["Residuals", "Sum Sq"] / AVT["Residuals", "Df"]
AVT["Regression", "F value"] = round(AVT["Regression", "Mean Sq"] / AVT["Residuals", "Mean Sq"], 1)
AVT["Regression", "Pr(>F)"] = round(1-pf(AVT["Regression", "F value"], 
                                         AVT["Regression", "Df"], 
                                         AVT["Residuals", "Df"]), 6)
print(AVT)
```

## 6) 잔차 산점도 - 1 : (독립변수, 잔차)

```{r}
# 6) 잔차 산점도 : (독립변수, 잔차)
par(mfrow=c(1,2), pty="s")
plot(chemical$speed, chemical.lm$resid, pch=19)
abline(h=0, lty=2)
for (i in 1:length(chemical$speed))
{
  if(abs(chemical.lm$resid[i]) > 3.7)
  {
    text(chemical$speed[i]+0.3, chemical.lm$resid[i]-0.4, as.character(i))
  }
}

plot(chemical$temp, chemical.lm$resid, pch=19)
abline(h=0, lty=2)
for (i in 1:length(chemical$temp))
{
  if(abs(chemical.lm$resid[i]) > 3.7)
  {
    text(chemical$temp[i]+0.3, chemical.lm$resid[i]-0.3, as.character(i)) 
  }
}
```

## 6) 잔차 산점도 -2 : (추정값, 잔차)

```{r}
plot(chemical.lm$fitted, chemical.lm$resid)
abline(h=0, lty=2)
for (i in 1:length(chemical$temp))
{
    text(chemical.lm$fitted[i]+0.3, chemical.lm$resid[i]-0.4, as.character(i)) 
}
```
